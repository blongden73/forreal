<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Liquid Background</title>
    <style>
        /* Basic styles to make the canvas fullscreen and remove scrollbars */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <!-- Vertex Shader: Positions the vertices of the plane we draw on. -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <!-- Fragment Shader: Calculates the color for each pixel, creating the liquid effect. -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        
        // We can store data for up to 10 ripples at a time
        const int MAX_RIPPLES = 10;
        uniform vec3 u_ripples[MAX_RIPPLES]; // x, y: position; z: start time

        // 2D noise function to create organic patterns
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        // Fractional Brownian Motion - layering noise for a more complex texture
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 6
        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 0.0;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            
            // --- Ripple Calculation ---
            float total_displacement = 0.0;
            for (int i = 0; i < MAX_RIPPLES; i++) {
                // Check if the ripple is active (start time > 0)
                if (u_ripples[i].z > 0.0) {
                    float time_since_click = u_time - u_ripples[i].z;
                    
                    // Ripple properties
                    float max_ripple_time = 3.0; // How long a ripple lasts
                    float ripple_speed = 1.2;
                    float ripple_frequency = 40.0;
                    float ripple_amplitude = 0.015;

                    if (time_since_click < max_ripple_time) {
                        vec2 ripple_center = u_ripples[i].xy;
                        float dist = distance(uv, ripple_center);
                        
                        // Calculate the wave that expands outwards
                        float wave = sin(dist * ripple_frequency - time_since_click * ripple_speed * 5.0);
                        
                        // Fade the ripple out at its edges
                        float falloff = 1.0 - smoothstep(0.0, 0.2, dist);
                        
                        // Fade the ripple out over time
                        float time_falloff = 1.0 - smoothstep(max_ripple_time * 0.7, max_ripple_time, time_since_click);

                        total_displacement += wave * falloff * time_falloff * ripple_amplitude;
                    }
                }
            }
            
            vec2 displaced_uv = uv + total_displacement;

            // --- Liquid Flow & Color ---
            // Animate the noise patterns over time to create a flowing effect
            vec2 uv1 = displaced_uv * 1.5 + vec2(u_time * 0.05, u_time * 0.03);
            vec2 uv2 = displaced_uv * 2.0 - vec2(u_time * -0.07, u_time * 0.04);
            vec2 uv3 = displaced_uv * 2.5 + vec2(u_time * 0.1, u_time * -0.05);

            // Layering different noise patterns for a rich, oily texture
            float noise_pattern = fbm(uv1) * 0.5 + fbm(uv2) * 0.3 + fbm(uv3) * 0.2;
            
            // Generate iridescent colors using trigonometric functions, inspired by the reference image
            float r = sin(noise_pattern * 4.0 + u_time * 0.2 + displaced_uv.x * 2.0) * 0.5 + 0.5;
            float g = cos(noise_pattern * 5.0 - u_time * 0.3 + displaced_uv.y * 3.0) * 0.5 + 0.5;
            float b = sin(noise_pattern * 6.0 + u_time * 0.1 - displaced_uv.x * 4.0) * 0.5 + 0.5;

            gl_FragColor = vec4(r, g, b, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL is not supported by your browser.');
        }

        // --- Shader Compilation & Program Linking ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(shaderProgram);

        // --- Geometry Setup (a simple plane to cover the screen) ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0,  1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Uniforms (variables passed from JS to the shader) ---
        const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
        const rippleUniformLocation = gl.getUniformLocation(shaderProgram, 'u_ripples');

        // --- Ripple Management ---
        const MAX_RIPPLES = 10;
        const ripples = [];
        for (let i = 0; i < MAX_RIPPLES; i++) {
            ripples.push({ x: 0, y: 0, startTime: -1 });
        }
        let currentRippleIndex = 0;
        let isInteracting = false; // Tracks mouse down or touch start

        // Helper function to create a ripple at a specific coordinate
        function createRipple(x, y) {
            const rect = canvas.getBoundingClientRect();
            const ripple = ripples[currentRippleIndex];
            
            // Convert pixel coords to WebGL normalized coords (0 to 1)
            // We use clientWidth and clientHeight to match the CSS display size, fixing the offset issue.
            ripple.x = (x - rect.left) / canvas.clientWidth;
            ripple.y = 1.0 - ((y - rect.top) / canvas.clientHeight); // Flip Y-axis
            ripple.startTime = performance.now() / 1000.0; // Store time in seconds

            // Cycle through the ripple array
            currentRippleIndex = (currentRippleIndex + 1) % MAX_RIPPLES;
        }

        // --- Mouse Event Listeners ---
        canvas.addEventListener('mousedown', (event) => {
            isInteracting = true;
            createRipple(event.clientX, event.clientY);
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isInteracting) {
                createRipple(event.clientX, event.clientY);
            }
        });

        window.addEventListener('mouseup', () => {
            isInteracting = false;
        });
        
        // --- Touch Event Listeners ---
        canvas.addEventListener('touchstart', (event) => {
            isInteracting = true;
            // Prevent default touch behavior like scrolling
            event.preventDefault(); 
            for (let i = 0; i < event.touches.length; i++) {
                createRipple(event.touches[i].clientX, event.touches[i].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            if (isInteracting) {
                for (let i = 0; i < event.touches.length; i++) {
                    createRipple(event.touches[i].clientX, event.touches[i].clientY);
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isInteracting = false;
        });

        // --- Render Loop ---
        function render(time) {
            time *= 0.001; // convert time to seconds

            // Resize canvas to match display size
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = Math.round(canvas.clientWidth * dpr);
            const displayHeight = Math.round(canvas.clientHeight * dpr);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            // Update uniforms
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform1f(timeUniformLocation, time);

            // Prepare ripple data for the shader
            const rippleData = new Float32Array(MAX_RIPPLES * 3);
            ripples.forEach((ripple, i) => {
                // If a ripple is too old, reset its start time so the shader ignores it
                if (time - ripple.startTime > 3.0) {
                    ripple.startTime = -1.0;
                }
                const offset = i * 3;
                rippleData[offset] = ripple.x;
                rippleData[offset + 1] = ripple.y;
                rippleData[offset + 2] = ripple.startTime;
            });
            gl.uniform3fv(rippleUniformLocation, rippleData);
            
            // Draw the scene
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>


