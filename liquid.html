<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Liquid Background</title>
    <style>
        /* Basic styles to make the canvas fullscreen and remove scrollbars */
        html, body {
            margin: 0;
            padding: 0;
            /* overflow: hidden; */ /* Allow scrolling now */
            height: 100%;
            background-color: #000;
        }

        .fixed-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .logo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: auto;
            z-index: 10;
            pointer-events: none; /* Allows clicks to go through to the canvas */
            transition: opacity 0.1s ease-out, filter 0.1s ease-out; /* Smooth transitions */
        }

        .scroll-content {
            position: relative;
            z-index: 2;
            background-color: transparent;
            pointer-events: none; /* Allow clicks to pass through this container */
        }

        .spacer {
            height: 100vh; /* Pushes the grid down, making space for the initial view */
        }

        .grid-container {
            width: 90vw;
            margin: 10vh auto;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3vw;
            pointer-events: auto; /* Re-enable pointer events for the grid content */
        }

        .grid-item {
            background-color: #000;
            aspect-ratio: 16 / 9;
            border-radius: 12px;
        }

    </style>
</head>
<body>
    <div class="fixed-background">
        <svg class="logo" viewBox="0 0 3104 295" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clip-path="url(#clip0_619_14)">
            <path d="M1206.73 157.893C1214.07 155.651 1225.01 155.719 1234.05 152.934C1263.44 143.9 1271.76 125.22 1273.5 95.571C1278.15 15.3171 1224.44 9.98495 1158.96 4.68677L862.588 4.75469V290.041H984.835V206.833H1123.22C1126.75 206.833 1142.62 212.505 1145.37 215.256C1147.48 217.327 1151.25 229.112 1151.25 231.456V290.041H1273.5V222.965C1273.5 217.871 1270.51 202.486 1268.74 197.153C1259.53 169.44 1229.26 165.602 1203.91 162.681C1203.44 160.338 1204.49 158.572 1206.73 157.893ZM1138.34 128.549C1135.86 129.534 1125.22 132.115 1123.22 132.115H987.383L984.835 129.568V79.4726C1026.18 81.6462 1070.39 76.6198 1111.43 79.4047C1122.98 80.1859 1143.98 82.5293 1148.74 94.7219C1153.39 106.677 1151.79 123.217 1138.34 128.549Z" fill="white"/>
            <path d="M543.008 1.86784C591.798 -0.781251 655.503 -1.29069 703.58 4.99241C810.945 19.053 835.271 70.0989 828.68 173.787C825.52 223.474 804.319 260.732 756.481 278.188C696.207 300.196 535.703 299.347 473.357 282.773C400.546 263.415 383.218 215.799 383.66 144.783C384.339 33.8267 441.623 7.3698 543.008 1.86784ZM575.285 81.6802C554.764 83.1745 522.656 86.9104 513.653 108.341C506.721 124.847 507.299 172.157 514.978 188.527C524.899 209.754 559.011 212.538 579.838 213.693C607.699 215.221 677.214 216.512 695.425 193.282C710.783 173.685 709.458 109.767 687.781 93.8728C666.104 77.9782 601.311 79.7783 575.319 81.6802H575.285Z" fill="white"/>
            <path d="M1757.42 162.681V157.587C1780.42 157.383 1809.47 150.115 1819.83 127.428C1827.28 111.058 1827.72 71.2197 1822.76 54.0346C1810.25 10.4944 1749.61 8.01511 1712.5 4.68677L1416.13 4.75469V290.041H1538.41V206.833H1676.79C1679.41 206.833 1694.53 211.927 1696.94 213.829C1699.05 215.527 1703.09 222.795 1703.09 224.663V290.041H1825.37V209.38C1825.37 205.916 1820.82 194.131 1818.88 190.395C1807.23 167.844 1779.95 166.111 1757.42 162.681ZM1692.93 127.869C1690.45 128.99 1678.77 132.115 1676.79 132.115H1538.41V79.4726H1670C1672.24 79.4726 1683.83 82.0878 1686.89 82.9708C1695.21 85.3821 1701.56 89.9671 1702.99 99.1031C1704.72 110.243 1704.38 122.775 1692.93 127.869Z" fill="white"/>
            <path d="M2214.23 3.05664V79.4727H1986.69V108.341H2214.23V184.757H1986.69V213.625H2214.23V290.041H1862.75V3.05664H2214.23Z" fill="white"/>
            <path d="M2584.4 5.56982H2397.6L2234.58 290.041H2366.17L2397.06 239.403L2575.13 238.995L2580.15 240.762L2607.3 290.041H2745.69L2584.4 5.56982ZM2436.64 166.078C2441.63 155.515 2481.56 75.9745 2486.75 75.9745C2490.08 76.0085 2494.6 85.4841 2496.37 88.5067L2536.83 166.078H2436.64Z" fill="white"/>
            <path d="M351.484 3.05664V79.4727H123.945V108.341H351.484V184.757H123.945V290.041H0V3.05664H351.484Z" fill="white"/>
            <path d="M2891.75 201.738H3104V290.041H2767.77V3.05664H2889.2L2891.75 5.60384V201.738Z" fill="white"/>
            </g>
            <defs>
            <clipPath id="clip0_619_14">
            <rect width="3104" height="295" fill="white"/>
            </clipPath>
            </defs>
        </svg>
        
        <!-- This SVG is for the centered text. It's hidden and will be drawn onto the WebGL canvas. -->
        <svg id="text-svg" style="display: none;" width="658" height="25" viewBox="0 0 658 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M648.815 24H645.465V4.34089H636.931V1.43311H657.349V4.34089H648.815V24Z" fill="white"/>
            <path d="M634.353 24H630.465L615.958 6.04763H615.895V24H612.545V1.43311H616.432L630.94 19.3855H631.003V1.43311H634.353V24Z" fill="white"/>
            <path d="M604.267 15.8772V1.43311H607.617V15.4663C607.617 21.5347 604.204 24.5689 597.409 24.5689C590.613 24.5689 587.2 21.5347 587.2 15.4663V1.43311H590.55V15.8772C590.55 19.67 592.952 21.6612 597.409 21.6612C601.928 21.6612 604.267 19.67 604.267 15.8772Z" fill="white"/>
            <path d="M558.529 12.7165C558.529 6.39527 562.575 0.800951 571.077 0.864163C579.326 0.737737 583.719 6.33206 583.624 12.7165C583.687 19.101 579.421 24.6953 571.077 24.5689C562.733 24.6953 558.434 19.0378 558.529 12.7165ZM561.879 12.7165C561.911 18.3741 565.482 21.6295 571.077 21.6611C576.734 21.6295 580.242 18.3109 580.274 12.7165C580.274 9.93518 579.452 7.75434 577.809 6.17403C576.134 4.59371 573.89 3.80355 571.077 3.77194C565.419 3.80355 561.911 7.15382 561.879 12.7165Z" fill="white"/>
            <path d="M552.542 15.3715H555.892C555.45 20.3653 550.772 24.6953 544.609 24.5689C537.466 24.5689 532.63 19.9228 532.756 12.6533C532.756 5.95278 536.96 0.927375 544.577 0.864161C550.045 0.832555 555.45 3.58231 555.892 9.5559H552.542C552.005 6.0476 549.16 3.77194 544.83 3.77194C539.267 3.77194 536.107 7.09061 536.107 13.001C536.075 18.1528 539.425 21.7875 544.64 21.6611C548.907 21.6611 551.625 19.5119 552.542 15.3715Z" fill="white"/>
            <path d="M518.453 24H514.565L500.058 6.04763H499.995V24H496.645V1.43311H500.532L515.039 19.3855H515.103V1.43311H518.453V24Z" fill="white"/>
            <path d="M467.784 12.7165C467.784 6.39527 471.83 0.800951 480.332 0.864163C488.581 0.737737 492.974 6.33206 492.88 12.7165C492.943 19.101 488.676 24.6953 480.332 24.5689C471.988 24.6953 467.689 19.0378 467.784 12.7165ZM471.135 12.7165C471.166 18.3741 474.738 21.6295 480.332 21.6611C485.99 21.6295 489.498 18.3109 489.529 12.7165C489.529 9.93518 488.708 7.75434 487.064 6.17403C485.389 4.59371 483.145 3.80355 480.332 3.77194C474.674 3.80355 471.166 7.15382 471.135 12.7165Z" fill="white"/>
            <path d="M463.855 24H460.505V1.43311H463.855V24Z" fill="white"/>
            <path d="M456.554 7.94401H453.204C452.793 5.06784 450.517 3.77198 446.503 3.77198C443.501 3.77198 441.257 5.19426 441.257 7.46992C441.257 8.95542 442.3 9.96682 444.955 10.4409L450.486 11.3891C451.908 11.6736 452.951 11.9264 453.646 12.2109C454.31 12.4953 454.942 12.8746 455.511 13.3171C456.617 14.2021 457.281 15.4347 457.281 17.1731C457.218 22.4197 452.983 24.5689 447.578 24.5689C441.762 24.5689 437.211 22.2301 437.211 16.5725H440.561C440.656 19.8596 443.185 21.6612 447.831 21.6612C451.592 21.6612 453.931 20.1441 453.931 17.8368C453.931 15.8456 452.477 14.9606 449.727 14.4865L444.607 13.6332C441.478 13.1275 439.866 12.2741 438.76 10.6938C438.191 9.90361 437.906 8.92381 437.906 7.72277C437.906 3.51913 441.288 0.864197 446.946 0.864197C452.666 0.864197 456.27 3.29788 456.554 7.94401Z" fill="white"/>
            <path d="M435.473 7.94401H432.123C431.712 5.06784 429.436 3.77198 425.422 3.77198C422.42 3.77198 420.176 5.19426 420.176 7.46992C420.176 8.95542 421.219 9.96682 423.873 10.4409L429.405 11.3891C430.827 11.6736 431.87 11.9264 432.565 12.2109C433.229 12.4953 433.861 12.8746 434.43 13.3171C435.536 14.2021 436.2 15.4347 436.2 17.1731C436.137 22.4197 431.901 24.5689 426.497 24.5689C420.681 24.5689 416.13 22.2301 416.13 16.5725H419.48C419.575 19.8596 422.104 21.6612 426.75 21.6612C430.511 21.6612 432.85 20.1441 432.85 17.8368C432.85 15.8456 431.396 14.9606 428.646 14.4865L423.526 13.6332C420.397 13.1275 418.785 12.2741 417.679 10.6938C417.11 9.90361 416.825 8.92381 416.825 7.72277C416.825 3.51913 420.207 0.864197 425.865 0.864197C431.585 0.864197 435.189 3.29788 435.473 7.94401Z" fill="white"/>
            <path d="M414.262 24H395.804V1.43311H413.946V4.34089H399.154V10.8834H413.503V13.7912H399.154V21.0922H414.262V24Z" fill="white"/>
            <path d="M392.65 24H389.11C388.92 23.7788 388.794 23.4627 388.699 23.0202C388.604 22.5777 388.509 21.4715 388.415 19.7016C388.193 15.9404 387.087 14.4233 384.053 14.4233H375.298V24H371.948V1.43311H385.918C389.837 1.43311 392.081 3.93001 392.081 7.43831C392.081 10.2197 390.817 12.2109 388.288 13.001V13.0642C390.311 13.3487 391.449 15.2135 391.575 17.8684C391.607 18.6902 391.67 19.7964 391.765 21.1555C391.86 22.5461 392.176 23.4943 392.65 24ZM384.748 4.34089H375.298V11.5155H384.654C387.308 11.5155 388.731 10.1881 388.731 7.94401C388.731 5.76317 387.403 4.37249 384.748 4.34089Z" fill="white"/>
            <path d="M352.488 24H349.138V1.43311H360.769C365.731 1.43311 368.323 3.70876 368.323 7.9124C368.323 12.3373 365.542 14.9606 360.99 14.9606H352.488V24ZM361.148 4.34089H352.488V12.0528H360.548C363.456 12.0528 364.973 10.6622 364.973 7.97561C364.973 5.73157 363.582 4.34089 361.148 4.34089Z" fill="white"/>
            <path d="M344.158 24H340.808V5.28908H340.745L331.958 24H328.987L320.232 5.66835H320.169V24H316.819V1.43311H321.528L330.473 20.144L339.512 1.43311H344.158V24Z" fill="white"/>
            <path d="M311.657 24H308.307V1.43311H311.657V24Z" fill="white"/>
            <path d="M285.276 24H281.926V14.7078L272.033 1.43311H276.3L283.664 11.7052L291.155 1.43311H295.232L285.276 14.5497V24Z" fill="white"/>
            <path d="M271.502 24H267.963C267.773 23.7788 267.646 23.4627 267.552 23.0202C267.457 22.5777 267.362 21.4715 267.267 19.7016C267.046 15.9404 265.94 14.4233 262.906 14.4233H254.151V24H250.8V1.43311H264.77C268.689 1.43311 270.934 3.93001 270.934 7.43831C270.934 10.2197 269.669 12.2109 267.141 13.001V13.0642C269.164 13.3487 270.301 15.2135 270.428 17.8684C270.459 18.6902 270.523 19.7964 270.617 21.1555C270.712 22.5461 271.028 23.4943 271.502 24ZM263.601 4.34089H254.151V11.5155H263.506C266.161 11.5155 267.583 10.1881 267.583 7.94401C267.583 5.76317 266.256 4.37249 263.601 4.34089Z" fill="white"/>
            <path d="M246.878 24H228.42V1.43311H246.562V4.34089H231.77V10.8834H246.119V13.7912H231.77V21.0922H246.878V24Z" fill="white"/>
            <path d="M216.451 24H212.88L202.829 1.43311H206.622L214.744 20.5233L222.741 1.43311H226.344L216.451 24Z" fill="white"/>
            <path d="M201.814 24H183.356V1.43311H201.498V4.34089H186.706V10.8834H201.056V13.7912H186.706V21.0922H201.814V24Z" fill="white"/>
            <path d="M169.004 24H150.546V1.43311H168.688V4.34089H153.896V10.8834H168.246V13.7912H153.896V21.0922H169.004V24Z" fill="white"/>
            <path d="M147.993 24H143.378L134.149 13.001L130.04 16.6357V24H126.69V1.43311H130.04V12.7798L142.651 1.43311H147.392L136.678 10.7886L147.993 24Z" fill="white"/>
            <path d="M124.263 24H120.439L117.562 17.4259H106.5L103.624 24H100.021L110.23 1.43311H114.054L124.263 24ZM116.33 14.5181L112 4.53052L107.765 14.5181H116.33Z" fill="white"/>
            <path d="M97.7277 24H94.3774V5.28908H94.3142L85.5276 24H82.5566L73.8017 5.66835H73.7385V24H70.3882V1.43311H75.0975L84.0421 20.144L93.0815 1.43311H97.7277V24Z" fill="white"/>
            <path d="M56.0362 24H37.5781V1.43311H55.7202V4.34089H40.9284V10.8834H55.2777V13.7912H40.9284V21.0922H56.0362V24Z" fill="white"/>
            <path d="M27.7242 24H24.0579L17.7998 5.28908H17.7366L11.5102 24H7.81224L0.384766 1.43311H4.01949L9.80344 19.7648H9.86665L15.9035 1.43311H19.8859L26.0807 19.7648H26.1439L31.8963 1.43311H35.373L27.7242 24Z" fill="white"/>
        </svg>
        <canvas id="glCanvas"></canvas>
    </div>

    <div class="scroll-content">
        <div class="spacer"></div>
        <div class="grid-container">
            <div class="grid-item"></div>
            <div class="grid-item"></div>
            <div class="grid-item"></div>
            <div class="grid-item"></div>
            <div class="grid-item"></div>
            <div class="grid-item"></div>
            <div class="grid-item"></div>
            <div class="grid-item"></div>
        </div>
    </div>
    
    <!-- Vertex Shader: Positions the vertices of the plane we draw on. -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <!-- Fragment Shader: Calculates the color for each pixel, creating the liquid effect. -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        
        const int MAX_RIPPLES = 10;
        uniform vec4 u_ripples[MAX_RIPPLES]; // x, y: position; z: start time; w: pressure
        uniform vec2 u_ripple_velocities[MAX_RIPPLES]; // New uniform for ripple velocities

        // New uniforms for the text texture
        uniform sampler2D u_textTexture;
        uniform vec2 u_textResolution;
        uniform float u_fade_progress; // Uniform for scroll-based fade

        // 2D noise function to create organic patterns
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        // Fractional Brownian Motion - layering noise for a more complex texture
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 6
        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 0.0;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            
            // --- Ripple Calculation ---
            float total_displacement = 0.0;
            for (int i = 0; i < MAX_RIPPLES; i++) {
                // Check if the ripple is active (start time > 0)
                if (u_ripples[i].z > 0.0) {
                    float time_since_click = u_time - u_ripples[i].z;
                    float pressure = u_ripples[i].w; // Get pressure from the 4th component
                    
                    // Further toned down the effect of pressure for an even more subtle feel
                    float max_ripple_time = 3.0 + pressure * 1.5;     // Lasts even shorter
                    float ripple_speed = 1.2;
                    float ripple_frequency = 40.0 - pressure * 10.0;  // Even less widening
                    float ripple_amplitude = 0.015 + pressure * 0.015; // Even less deep

                    if (time_since_click < max_ripple_time) {
                        vec2 ripple_center = u_ripples[i].xy;
                        vec2 velocity = u_ripple_velocities[i];
                        float vel_mag = length(velocity);

                        vec2 dist_vec = uv - ripple_center;

                        // If moving, stretch the ripple shape to be elliptical
                        if (vel_mag > 0.01) { // Threshold to avoid stretching from noise
                            vec2 vel_dir = normalize(velocity);
                            // Use smoothstep to ease into the stretch and cap its max effect for a more natural shape
                            float stretch_factor = 1.0 + smoothstep(0.0, 1.5, vel_mag) * 2.0;
                            
                            // Decompose the distance vector into components parallel and perpendicular to the velocity
                            vec2 parallel_component = dot(dist_vec, vel_dir) * vel_dir;
                            vec2 perpendicular_component = dist_vec - parallel_component;
                            
                            // Reconstruct the distance vector, compressing the perpendicular part to create an ellipse
                            dist_vec = parallel_component + perpendicular_component / stretch_factor;
                        }
                        
                        float dist = length(dist_vec);
                        
                        // Calculate the wave that expands outwards
                        float wave = sin(dist * ripple_frequency - time_since_click * ripple_speed * 5.0);
                        
                        // Fade the ripple out at its edges
                        float falloff = 1.0 - smoothstep(0.0, 0.2, dist);
                        
                        // Fade the ripple out over time
                        float time_falloff = 1.0 - smoothstep(max_ripple_time * 0.7, max_ripple_time, time_since_click);

                        total_displacement += wave * falloff * time_falloff * ripple_amplitude;
                    }
                }
            }
            
            vec2 displaced_uv = uv + total_displacement;

            // --- Liquid Flow & Color ---
            // Animate the noise patterns over time to create a flowing effect
            vec2 uv1 = displaced_uv * 1.5 + vec2(u_time * 0.05, u_time * 0.03);
            vec2 uv2 = displaced_uv * 2.0 - vec2(u_time * -0.07, u_time * 0.04);
            vec2 uv3 = displaced_uv * 2.5 + vec2(u_time * 0.1, u_time * -0.05);

            // Layering different noise patterns for a rich, oily texture
            float noise_pattern = fbm(uv1) * 0.5 + fbm(uv2) * 0.3 + fbm(uv3) * 0.2;
            
            // Generate iridescent colors using trigonometric functions, inspired by the reference image
            float r = sin(noise_pattern * 4.0 + u_time * 0.2 + displaced_uv.x * 2.0) * 0.5 + 0.5;
            float g = cos(noise_pattern * 5.0 - u_time * 0.3 + displaced_uv.y * 3.0) * 0.5 + 0.5;
            float b = sin(noise_pattern * 6.0 + u_time * 0.1 - displaced_uv.x * 4.0) * 0.5 + 0.5;
            
            vec4 liquidColor = vec4(r, g, b, 1.0);
            vec4 finalColor = liquidColor;

            // --- Text Overlay Calculation ---
            // Only run if the text texture has been loaded (resolution > 0)
            if (u_textResolution.x > 0.0) {
                // Calculate the dimensions of the text box in pixels, with a max width of 800px
                float textPixelWidth = min(800.0, u_resolution.x * 0.9);
                float textAspect = u_textResolution.x / u_textResolution.y;
                float textPixelHeight = textPixelWidth / textAspect;

                // Convert pixel dimensions to UV space (0 to 1) and center the box
                vec2 boxSize = vec2(textPixelWidth / u_resolution.x, textPixelHeight / u_resolution.y);
                vec2 boxStart = 0.5 - boxSize * 0.5;

                // Check if the current pixel's ORIGINAL uv is inside the text's bounding box
                if (uv.x > boxStart.x && uv.x < boxStart.x + boxSize.x &&
                    uv.y > boxStart.y && uv.y < boxStart.y + boxSize.y) {

                    // Use the DISPLACED uv to sample the text, creating the distortion effect.
                    // We map the displaced screen UVs to the text's local UVs (0 to 1).
                    vec2 textUV = (displaced_uv - boxStart) / boxSize;
                    
                    // Flip the Y-coordinate to correct the upside-down text
                    textUV.y = 1.0 - textUV.y;
                    
                    vec4 textColor = texture2D(u_textTexture, textUV);

                    // Blend the white text over the liquid using the text's alpha channel and the scroll fade progress.
                    finalColor = mix(finalColor, vec4(textColor.rgb, 1.0), textColor.a * u_fade_progress);
                }
            }

            gl_FragColor = finalColor;
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        const logoElement = document.querySelector('.logo');

        if (!gl) {
            alert('WebGL is not supported by your browser.');
        }

        // --- Shader Compilation & Program Linking ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(shaderProgram);

        // --- Geometry Setup (a simple plane to cover the screen) ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0,  1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Uniforms (variables passed from JS to the shader) ---
        const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
        const rippleUniformLocation = gl.getUniformLocation(shaderProgram, 'u_ripples');
        const rippleVelocitiesUniformLocation = gl.getUniformLocation(shaderProgram, 'u_ripple_velocities');
        const textTextureUniformLocation = gl.getUniformLocation(shaderProgram, 'u_textTexture');
        const textResolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_textResolution');
        const fadeProgressUniformLocation = gl.getUniformLocation(shaderProgram, 'u_fade_progress');

        // --- Ripple Management ---
        const MAX_RIPPLES = 10;
        const ripples = [];
        const rippleVelocities = []; // New array for velocities
        for (let i = 0; i < MAX_RIPPLES; i++) {
            ripples.push({ x: 0, y: 0, startTime: -1, pressure: 0 });
            rippleVelocities.push({ x: 0, y: 0 }); // Initialize velocities
        }
        let currentRippleIndex = 0;
        let isInteracting = false; // Tracks mouse down or touch start
        let interactionStartTime = 0; // Tracks when a click/touch begins
        let lastInteractionPos = { x: 0, y: 0, time: 0 }; // For velocity calculation

        // --- Scroll Fade Management ---
        let fadeProgress = 1.0;

        // --- Text Texture Setup ---
        let textTexture = null;
        let textImage = new Image();

        function setupTextTexture() {
            const svgElement = document.getElementById('text-svg');
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svgElement);

            // Use base64 encoding for the SVG to use it as an image source
            const svgBase64 = window.btoa(svgString);
            const dataUrl = 'data:image/svg+xml;base64,' + svgBase64;

            textImage.onload = function() {
                // Now that the image is loaded, create a WebGL texture from it
                textTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, textTexture);
                
                // Upload the image into the texture.
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textImage);

                // Set texture parameters. Non-power-of-2 textures need clamp_to_edge.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                
                // Start the render loop only after the texture is ready
                requestAnimationFrame(render);
            };

            textImage.src = dataUrl;
        }


        // Helper function to create a ripple at a specific coordinate
        function createRipple(x, y) {
            const rect = canvas.getBoundingClientRect();
            const ripple = ripples[currentRippleIndex];
            const rippleVelocity = rippleVelocities[currentRippleIndex];

            // Calculate velocity
            const currentTime = performance.now();
            const dt = currentTime - lastInteractionPos.time;
            let velX = 0, velY = 0;

            // Only calculate velocity if there's a previous point and time has passed
            if (dt > 1 && lastInteractionPos.time > 0) {
                const dx = x - lastInteractionPos.x; // dx/dy in CSS pixels
                const dy = y - lastInteractionPos.y;

                // Velocity in normalized screen space units per second
                velX = (dx / canvas.clientWidth) / (dt / 1000.0);
                velY = -(dy / canvas.clientHeight) / (dt / 1000.0); // Flip Y and normalize
            }
            lastInteractionPos = { x, y, time: currentTime };
            
            // Store velocity for the shader
            rippleVelocity.x = velX;
            rippleVelocity.y = velY;

            // Calculate pressure based on how long the mouse has been held down, ramping up slower.
            const duration = interactionStartTime > 0 ? (performance.now() - interactionStartTime) / 1000.0 : 0;
            const pressure = Math.min(1.0, duration * 0.4); // Reaches max pressure in 2.5 seconds for a gentler effect
            
            // Convert pixel coords to WebGL normalized coords (0 to 1)
            ripple.x = (x - rect.left) / canvas.clientWidth;
            ripple.y = 1.0 - ((y - rect.top) / canvas.clientHeight); // Flip Y-axis
            ripple.startTime = performance.now() / 1000.0; // Store time in seconds
            ripple.pressure = pressure;

            // Cycle through the ripple array
            currentRippleIndex = (currentRippleIndex + 1) % MAX_RIPPLES;
        }

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', (event) => {
            isInteracting = true;
            interactionStartTime = performance.now();
            lastInteractionPos = { x: 0, y: 0, time: 0 }; // Reset on new click
            createRipple(event.clientX, event.clientY);
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isInteracting) {
                createRipple(event.clientX, event.clientY);
            }
        });

        window.addEventListener('mouseup', () => {
            isInteracting = false;
            interactionStartTime = 0;
        });
        
        canvas.addEventListener('touchstart', (event) => {
            isInteracting = true;
            interactionStartTime = performance.now();
            lastInteractionPos = { x: 0, y: 0, time: 0 }; // Reset on new touch
            event.preventDefault(); 
            for (let i = 0; i < event.touches.length; i++) {
                createRipple(event.touches[i].clientX, event.touches[i].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            if (isInteracting) {
                for (let i = 0; i < event.touches.length; i++) {
                    createRipple(event.touches[i].clientX, event.touches[i].clientY);
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isInteracting = false;
            interactionStartTime = 0;
        });

        // --- Scroll Listener for Fade Effect ---
        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY;
            const fadeStart = 50;
            const fadeEnd = 400;

            let progress = 0;
            if (scrollY > fadeStart) {
                progress = Math.min(1, (scrollY - fadeStart) / (fadeEnd - fadeStart));
            }

            fadeProgress = 1.0 - progress;
            const blurAmount = progress * 10; // Max blur of 10px

            logoElement.style.opacity = fadeProgress;
            logoElement.style.filter = `blur(${blurAmount}px)`;
        });


        // --- Render Loop ---
        function render(time) {
            time *= 0.001; // convert time to seconds

            // Resize canvas to match display size
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = Math.round(canvas.clientWidth * dpr);
            const displayHeight = Math.round(canvas.clientHeight * dpr);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            // Update uniforms
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform1f(timeUniformLocation, time);
            gl.uniform1f(fadeProgressUniformLocation, fadeProgress); // Pass fade progress to shader

            // Prepare ripple data for the shader
            const rippleData = new Float32Array(MAX_RIPPLES * 4);
            const rippleVelocitiesData = new Float32Array(MAX_RIPPLES * 2);

            ripples.forEach((ripple, i) => {
                // If a ripple is too old, reset its start time so the shader ignores it.
                if (time - ripple.startTime > 7.0) { // 7s is a safe cleanup time
                    ripple.startTime = -1.0;
                }
                const offset = i * 4;
                rippleData[offset] = ripple.x;
                rippleData[offset + 1] = ripple.y;
                rippleData[offset + 2] = ripple.startTime;
                rippleData[offset + 3] = ripple.pressure;

                // Populate velocity data
                const velOffset = i * 2;
                const velocity = rippleVelocities[i];
                if (ripple.startTime < 0.0) { // If ripple is inactive, zero out velocity
                    rippleVelocitiesData[velOffset] = 0.0;
                    rippleVelocitiesData[velOffset + 1] = 0.0;
                } else {
                    rippleVelocitiesData[velOffset] = velocity.x;
                    rippleVelocitiesData[velOffset + 1] = velocity.y;
                }
            });
            gl.uniform4fv(rippleUniformLocation, rippleData);
            gl.uniform2fv(rippleVelocitiesUniformLocation, rippleVelocitiesData); // Send velocities

            // Update text texture uniforms if the texture is ready
            if (textTexture) {
                gl.uniform2f(textResolutionUniformLocation, textImage.width, textImage.height);
                
                // Tell the shader to use texture unit 0 for u_textTexture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, textTexture);
                gl.uniform1i(textTextureUniformLocation, 0);
            }
            
            // Draw the scene
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // Start the process by setting up the text texture, 
        // which will then kick off the render loop.
        setupTextTexture();
    </script>
</body>
</html>


