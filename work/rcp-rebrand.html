<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cossette+Texte:wght@400;700&family=Geologica:wght@100..900&display=swap" rel="stylesheet">
    <title>For Real | A branding & design agency that makes every impression count</title>
    <style>
        /* Basic styles to make the canvas fullscreen and remove scrollbars */
        html, body {
            margin: 0;
            padding: 0;
            /* overflow: hidden; */ /* Allow scrolling now */
            height: 100%;
            background-color: #000;
            font-family: "Cossette Texte", sans-serif;
        }

        .geo {
            font-family: "Geologica", sans-serif;
        }

        .fixed-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .logo {
            position: absolute;
            top: 30px;
            left: 50%;
            width: 90%;
            height: auto;
            z-index: 10;
            transform: translateX(-50%);
            pointer-events: none; /* Allows clicks to go through to the canvas */
            transition: opacity 0.1s ease-out, filter 0.1s ease-out; /* Smooth transitions */
        }

        .scroll-content {
            position: relative;
            z-index: 2;
            background-color: transparent;
            pointer-events: all; /* Allow clicks to pass through this container */
        }

        .spacer {
            height: 100vh; /* Pushes the grid down, making space for the initial view */
        }

        .spacer.case-study {
            height: 75vh;
        }

        .grid-container {
            width: 100vw;
            margin: auto auto;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5vw;
            pointer-events: auto; /* Re-enable pointer events for the grid content */
            background-color: #000;
        }

        .grid-container.case-study {
            display: block;
            grid-auto-columns: none;
            gap: none;
        }

        .grid-container.case-study .full-width {
            width: 100%;
        }

        .grid-container.case-study .full-width img{
            width: 100%;
        }

        .grid-item {
            background-color: #000;
            aspect-ratio: 16 / 9;
            position: relative;
        }

        .grid-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .grid-item:hover img{
            opacity: 0.3;
        }

        .studio-descriptor {
            font-family: "Cossette Texte", sans-serif;
            font-weight: 400;
            font-style: normal;
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 22px;
            border-top: 1px solid #fff;
            padding-top: 10px;
            width: 98%;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.1s ease-out, filter 0.1s ease-out;
        }

        .footer {
            background-color: #000;
        }

        .footer .flex{
            display: flex;
            width: 96vw;
            padding-top: 60px;
            margin-left: auto;
            margin-right: auto;
            padding-bottom: 60px;
            justify-content: space-between;
        }

        .footer .flex .footer-logo {
            width: 300px;
        }

        .footer .flex .footer-logo svg {
            width: 100%;
            height: auto;
        }

        .footer .flex .footer-message {
            color: #fff;
        }

        a {
            color: inherit;
        }

        .work-section-title {
            font-size: 1.1vw;
            color: #fff;
            font-family: "Cossette Texte", sans-serif;
        }

        .flex-sticky-header {
            width: 30vw;
            margin: 2vh auto;
            position: fixed;
            bottom: 30px;
            display: flex;
            justify-content: space-between;
            z-index: 100000;
            background-color: #57575755;
            left: 50%;
            transform: translateX(-50%);
            backdrop-filter: blur(20px);
            padding-top: 10px;
            padding-bottom: 10px;
            padding-left: 20px;
            padding-right: 20px;
            border-radius: 8px;
        }

        .project-title {
            color: #fff;
            font-size: 14px;
            margin-top: 10px;
            padding-left: 6px;
            width: 90%;
            margin-bottom: 20px;
            position: absolute;
            bottom: 10px;
            left: 20px;
        }

        .two-col {
            display: flex;
            justify-content: space-between;
        }

        .two-col .col{
            width: 49.5%;
        }

        .two-col .col img{
            width: 100%;
        }

        .full-width {
            margin-bottom: 20px;
            margin-top: 20px;
        }

        .project-description {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            display: flex;
            width: 90%;
        }

        .project-description h1 {
            color: #fff;
            line-height: 1;
            margin: 0;
        }

        .project-description h1.client {
            color: #848484;
        }

        .project-description p {
            color: #fff;
        }

        .cols {
            width: 50%;
        }

        .cols.description p{
            line-height: 1.4;
            margin-right: 150px;
        }

        a {
            text-decoration: none;
        }

        .col.padd {
            position: relative;
        }

        .col.padd img{
            width: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .video-background iframe{
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0;
        }

        .quick-menu {
            display: flex;
            flex-direction: row;
            margin: 2vh auto;
            position: fixed;
            bottom: 100px;
            z-index: 100000;
            left: 50%;
            transform: translate(-50%, 50px);
            opacity: 0;
            pointer-events: none;
            transition: all ease-in-out 0.3s;
        }

        .quick-menu.active {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, 0px);
        }

        .quick-menu .grid-item {
            width: 130px;
            margin-right: 10px;
            transition: all ease-in-out 0.3s;
        }

        .quick-menu .grid-item:hover {
            transform: translateY(-10px);
            width: 150px;
        }

        .sticky-logo {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 1000;
            width: 200px;
            transform: translateY(-100px);
            transition: all ease-in-out 0.3s;
        }

        .sticky-logo.active {
            transform: translateY(0);
        }

        .sticky-logo svg {
            width: 100%;
            height: auto;
        }

    </style>
</head>
<body>
    <div class="fixed-background">
        <svg class="logo" viewBox="0 0 3104 295" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clip-path="url(#clip0_619_14)">
            <path d="M1206.73 157.893C1214.07 155.651 1225.01 155.719 1234.05 152.934C1263.44 143.9 1271.76 125.22 1273.5 95.571C1278.15 15.3171 1224.44 9.98495 1158.96 4.68677L862.588 4.75469V290.041H984.835V206.833H1123.22C1126.75 206.833 1142.62 212.505 1145.37 215.256C1147.48 217.327 1151.25 229.112 1151.25 231.456V290.041H1273.5V222.965C1273.5 217.871 1270.51 202.486 1268.74 197.153C1259.53 169.44 1229.26 165.602 1203.91 162.681C1203.44 160.338 1204.49 158.572 1206.73 157.893ZM1138.34 128.549C1135.86 129.534 1125.22 132.115 1123.22 132.115H987.383L984.835 129.568V79.4726C1026.18 81.6462 1070.39 76.6198 1111.43 79.4047C1122.98 80.1859 1143.98 82.5293 1148.74 94.7219C1153.39 106.677 1151.79 123.217 1138.34 128.549Z" fill="white"/>
            <path d="M543.008 1.86784C591.798 -0.781251 655.503 -1.29069 703.58 4.99241C810.945 19.053 835.271 70.0989 828.68 173.787C825.52 223.474 804.319 260.732 756.481 278.188C696.207 300.196 535.703 299.347 473.357 282.773C400.546 263.415 383.218 215.799 383.66 144.783C384.339 33.8267 441.623 7.3698 543.008 1.86784ZM575.285 81.6802C554.764 83.1745 522.656 86.9104 513.653 108.341C506.721 124.847 507.299 172.157 514.978 188.527C524.899 209.754 559.011 212.538 579.838 213.693C607.699 215.221 677.214 216.512 695.425 193.282C710.783 173.685 709.458 109.767 687.781 93.8728C666.104 77.9782 601.311 79.7783 575.319 81.6802H575.285Z" fill="white"/>
            <path d="M1757.42 162.681V157.587C1780.42 157.383 1809.47 150.115 1819.83 127.428C1827.28 111.058 1827.72 71.2197 1822.76 54.0346C1810.25 10.4944 1749.61 8.01511 1712.5 4.68677L1416.13 4.75469V290.041H1538.41V206.833H1676.79C1679.41 206.833 1694.53 211.927 1696.94 213.829C1699.05 215.527 1703.09 222.795 1703.09 224.663V290.041H1825.37V209.38C1825.37 205.916 1820.82 194.131 1818.88 190.395C1807.23 167.844 1779.95 166.111 1757.42 162.681ZM1692.93 127.869C1690.45 128.99 1678.77 132.115 1676.79 132.115H1538.41V79.4726H1670C1672.24 79.4726 1683.83 82.0878 1686.89 82.9708C1695.21 85.3821 1701.56 89.9671 1702.99 99.1031C1704.72 110.243 1704.38 122.775 1692.93 127.869Z" fill="white"/>
            <path d="M2214.23 3.05664V79.4727H1986.69V108.341H2214.23V184.757H1986.69V213.625H2214.23V290.041H1862.75V3.05664H2214.23Z" fill="white"/>
            <path d="M2584.4 5.56982H2397.6L2234.58 290.041H2366.17L2397.06 239.403L2575.13 238.995L2580.15 240.762L2607.3 290.041H2745.69L2584.4 5.56982ZM2436.64 166.078C2441.63 155.515 2481.56 75.9745 2486.75 75.9745C2490.08 76.0085 2494.6 85.4841 2496.37 88.5067L2536.83 166.078H2436.64Z" fill="white"/>
            <path d="M351.484 3.05664V79.4727H123.945V108.341H351.484V184.757H123.945V290.041H0V3.05664H351.484Z" fill="white"/>
            <path d="M2891.75 201.738H3104V290.041H2767.77V3.05664H2889.2L2891.75 5.60384V201.738Z" fill="white"/>
            </g>
            <defs>
            <clipPath id="clip0_619_14">
            <rect width="3104" height="295" fill="white"/>
            </clipPath>
            </defs>
        </svg>
        <div class="project-description">
            <div class="cols">
                <h1>Putting the love back into Advertising</h1>
                <h1 class="client">RCP</h1>
            </div>
            <div class="cols description">
                <p>We helped Recipe Advertising find their true selves and got to the heart of what really matters: the love of advertising is what drives them forward and so we built a positioning and design system around that. We rebranded as RCP and doubled down on love. The identity consists of a bold tone of voice, a logo which symbolises their bonds with their clients and an everlasting love to the work they do. We created a brand film that sets them apart, that expresses their trueselves and places a stake in the ground for the industry.</p>
            </div>
        </div>
    </div>

    <div class="quick-menu">        
        <a href="/work/autotrader-found-at.html" class="grid-item">
            <img src="../images/AT-AutoTrader_LOGO_Centered_2408021-ezgif.com-video-to-gif-converter.gif">
        </a>
        <a href="/work/old-spice-big-man-ting.html" class="grid-item">
            <img src="../images/oldspice-1.jpg">
        </a> 
        <a href="/work/money-plus-rebrand.html" class="grid-item">
            <img src="../images/M+ney_A_gif.gif">
        </a>
        <a href="/work/betmgm-launch-design.html" class="grid-item">
            <img src="../images/betmgm_kv.jpg">
        </a>
        <a href="/work/rcp-rebrand.html" class="grid-item">
            <img src="../images/RCP.gif">
        </a>
        <div class="grid-item">
            <img src="../images/NNG_logo.gif">
        </div>
    </div>

    <div class="flex-sticky-header">
        <a href="/forreal/" class="work-section-title work-quick-menu">
            Work
        </a>
        <a href="/about" class="work-section-title">
            About
        </a>
        <a class="work-section-title">
            Contact
        </a>
    </div>

    <div class="spacer case-study"></div> 
    
    <div class="scroll-content">
        <div class="grid-container case-study">
            <div class="full-width">
                <img src="../images/rcp/rcp-1.gif">
            </div>
            <div class="two-col">
                <div class="col padd"><img src="../images/rcp/rcp-2.5.gif"></div>
                <div class="col"><img src="../images/rcp/rcp-3.jpg"></div>
            </div>
            <div class="full-width">
                <div class="video-background">
                    <div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/1119973960?autoplay=1&loop=1&background=1" style="position:absolute;top:0;left:0;width:100%;height:100%;" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>
                </div>
            </div>
            <div class="two-col">
                <div class="col"><img src="../images/rcp/rcp-5.jpg"></div>
                <div class="col"><img src="../images/rcp/rcp-6.jpg"></div>
            </div>
            <div class="full-width">
                <div class="video-background">
                    <div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/1119979815?autoplay=1&loop=1&background=1" style="position:absolute;top:0;left:0;width:100%;height:100%;" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>
                </div>
            </div>
            <div class="two-col">
                <div class="col"><img src="../images/rcp/rcp-8.jpg"></div>
                <div class="col"><img src="../images/rcp/rcp-9.jpg"></div>
            </div>
        </div>

        

        <div class="footer">
            <div class="flex">
                <div class="footer-logo">
                    <svg width="3104" height="295" viewBox="0 0 3104 295" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1206.73 157.893c7.34-2.242 18.28-2.174 27.32-4.959 29.39-9.034 37.71-27.714 39.45-57.363 4.65-80.254-49.06-85.586-114.54-90.884l-296.372.068V290.04h122.247v-83.208h138.385c3.53 0 19.4 5.672 22.15 8.423 2.11 2.071 5.88 13.856 5.88 16.2v58.585h122.25v-67.076c0-5.094-2.99-20.479-4.76-25.812-9.21-27.713-39.48-31.551-64.83-34.472-.47-2.343.58-4.109 2.82-4.788Zm-68.39-29.344c-2.48.985-13.12 3.566-15.12 3.566H987.383l-2.548-2.547V79.473c41.345 2.173 85.555-2.853 126.595-.068 11.55.78 32.55 3.124 37.31 15.317 4.65 11.955 3.05 28.495-10.4 33.827ZM543.008 1.868c48.79-2.65 112.495-3.159 160.572 3.124C810.945 19.053 835.271 70.1 828.68 173.787c-3.16 49.687-24.361 86.945-72.199 104.401-60.274 22.008-220.778 21.159-283.124 4.585-72.811-19.358-90.139-66.974-89.697-137.99C384.339 33.827 441.623 7.37 543.008 1.868Zm32.277 79.812c-20.521 1.494-52.629 5.23-61.632 26.661-6.932 16.506-6.354 63.816 1.325 80.186 9.921 21.227 44.033 24.011 64.86 25.166 27.861 1.528 97.376 2.819 115.587-20.411 15.358-19.597 14.033-83.515-7.644-99.41-21.677-15.894-86.47-14.094-112.462-12.192h-.034ZM1757.42 162.681v-5.094c23-.204 52.05-7.472 62.41-30.159 7.45-16.37 7.89-56.208 2.93-73.393-12.51-43.54-73.15-46.02-110.26-49.348l-296.37.068V290.04h122.28v-83.208h138.38c2.62 0 17.74 5.094 20.15 6.996 2.11 1.698 6.15 8.966 6.15 10.834v65.378h122.28V209.38c0-3.464-4.55-15.249-6.49-18.985-11.65-22.551-38.93-24.284-61.46-27.714Zm-64.49-34.812c-2.48 1.121-14.16 4.246-16.14 4.246h-138.38V79.473H1670c2.24 0 13.83 2.615 16.89 3.498 8.32 2.411 14.67 6.996 16.1 16.132 1.73 11.14 1.39 23.672-10.06 28.766ZM2214.23 3.057v76.416h-227.54v28.868h227.54v76.416h-227.54v28.868h227.54v76.416h-351.48V3.057h351.48ZM2584.4 5.57h-186.8L2234.58 290.04h131.59l30.89-50.638 178.07-.408 5.02 1.767 27.15 49.279h138.39L2584.4 5.57Zm-147.76 160.508c4.99-10.563 44.92-90.103 50.11-90.103 3.33.034 7.85 9.51 9.62 12.532l40.46 77.571h-100.19ZM351.484 3.057v76.416H123.945v28.868h227.539v76.416H123.945v105.284H0V3.057h351.484ZM2891.75 201.738H3104v88.303h-336.23V3.057h121.43l2.55 2.547v196.134Z" fill="#fff"/></svg>
                </div>
                <div class="footer-message">
                    FOR REAL is part of the <a href="/">Not Normal Group</a> 
                </div>
            </div>
        </div>
    </div>

    <script>
        // Select the element
        const stickyLogo = document.querySelector('.sticky-logo');

        // How far to scroll before activating (in pixels)
        const scrollThreshold = 300; // adjust as needed

        window.addEventListener('scroll', () => {
        if (!stickyLogo) return;

        const scrollY = window.scrollY;

        // Add or remove "active" class based on scroll position
        if (scrollY > scrollThreshold) {
            stickyLogo.classList.add('active');
        } else {
            stickyLogo.classList.remove('active');
        }
        });
    </script>

    <script>
        // Select the logo element
        const logo = document.querySelector('.logo');

        // Adjust how much faster the logo scrolls away
        const scrollSpeedMultiplier = 1.5;

        window.addEventListener('scroll', () => {
        if (!logo) return;

        const scrollY = window.scrollY;

        // Combine translateY for scroll effect with existing translateX(-50%) for centering
        logo.style.transform = `translateX(-50%) translateY(${-scrollY * scrollSpeedMultiplier}px)`;

        // Optional: make movement smoother
        logo.style.transition = 'transform 0.1s ease-out';
        });
    </script>

    <script>
        // Select the elements
        const workQuickMenus = document.querySelectorAll('.work-quick-menu');
        const quickMenu = document.querySelector('.quick-menu');

        let timeoutId = null;

        // Function to add the active class
        function activateQuickMenu() {
        if (!quickMenu) return;
        quickMenu.classList.add('active');

        // Clear any pending timeout to remove
        clearTimeout(timeoutId);
        }

        // Function to remove the active class after 20s if not hovered
        function deactivateQuickMenuWithDelay() {
        if (!quickMenu) return;
        
        // Clear any previous timeout
        clearTimeout(timeoutId);
        
        // Start a new 20s timeout
        timeoutId = setTimeout(() => {
            // Only remove if neither element is hovered
            const isHovered = [...workQuickMenus].some(menu => menu.matches(':hover')) || quickMenu.matches(':hover');
            if (!isHovered) {
            quickMenu.classList.remove('active');
            }
        }, 3000);
        }

        // Add hover listeners
        workQuickMenus.forEach(menu => {
        menu.addEventListener('mouseenter', activateQuickMenu);
        menu.addEventListener('mouseleave', deactivateQuickMenuWithDelay);
        });

        if (quickMenu) {
        quickMenu.addEventListener('mouseenter', activateQuickMenu);
        quickMenu.addEventListener('mouseleave', deactivateQuickMenuWithDelay);
        }
    </script>
    
    <!-- Vertex Shader: Positions the vertices of the plane we draw on. -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <!-- Fragment Shader: Calculates the color for each pixel, creating the liquid effect. -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        
        const int MAX_RIPPLES = 10;
        uniform vec4 u_ripples[MAX_RIPPLES]; // x, y: position; z: start time; w: pressure
        uniform vec2 u_ripple_velocities[MAX_RIPPLES]; // New uniform for ripple velocities

        // New uniforms for the text texture
        uniform sampler2D u_textTexture;
        uniform vec2 u_textResolution;
        uniform float u_fade_progress; // Uniform for scroll-based fade

        // New uniforms for the hover effect
        uniform vec2 u_hover_pos;
        uniform float u_hover_strength;

        // 2D noise function to create organic patterns
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        // Fractional Brownian Motion - layering noise for a more complex texture
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        #define OCTAVES 4
        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 0.0;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            
            // --- Ripple Calculation ---
            float total_displacement = 0.0;
            for (int i = 0; i < MAX_RIPPLES; i++) {
                // Check if the ripple is active (start time > 0)
                if (u_ripples[i].z > 0.0) {
                    float time_since_click = u_time - u_ripples[i].z;
                    float pressure = u_ripples[i].w; // Get pressure from the 4th component
                    
                    // Further toned down the effect of pressure for an even more subtle feel
                    float max_ripple_time = 3.0 + pressure * 1.5;     // Lasts even shorter
                    float ripple_speed = 1.2;
                    float ripple_frequency = 40.0 - pressure * 10.0;  // Even less widening
                    float ripple_amplitude = 0.015 + pressure * 0.015; // Even less deep

                    if (time_since_click < max_ripple_time) {
                        vec2 ripple_center = u_ripples[i].xy;
                        vec2 velocity = u_ripple_velocities[i];
                        float vel_mag = length(velocity);

                        vec2 dist_vec = uv - ripple_center;

                        // If moving, stretch the ripple shape to be elliptical
                        if (vel_mag > 0.01) { // Threshold to avoid stretching from noise
                            vec2 vel_dir = normalize(velocity);
                            // Use smoothstep to ease into the stretch and cap its max effect for a more natural shape
                            float stretch_factor = 1.0 + smoothstep(0.0, 1.5, vel_mag) * 2.0;
                            
                            // Decompose the distance vector into components parallel and perpendicular to the velocity
                            vec2 parallel_component = dot(dist_vec, vel_dir) * vel_dir;
                            vec2 perpendicular_component = dist_vec - parallel_component;
                            
                            // Reconstruct the distance vector, compressing the perpendicular part to create an ellipse
                            dist_vec = parallel_component + perpendicular_component / stretch_factor;
                        }
                        
                        float dist = length(dist_vec);
                        
                        // Calculate the wave that expands outwards
                        float wave = sin(dist * ripple_frequency - time_since_click * ripple_speed * 5.0);
                        
                        // Fade the ripple out at its edges
                        float falloff = 1.0 - smoothstep(0.0, 0.2, dist);
                        
                        // Fade the ripple out over time
                        float time_falloff = 1.0 - smoothstep(max_ripple_time * 0.7, max_ripple_time, time_since_click);

                        total_displacement += wave * falloff * time_falloff * ripple_amplitude;
                    }
                }
            }

            // --- Hover Effect Calculation ---
            if (u_hover_strength > 0.0) {
                float hover_dist = distance(uv, u_hover_pos);
                // Create a soft-edged "dent" under the cursor - increased radius and strength
                float hover_falloff = 1.0 - smoothstep(0.0, 0.1, hover_dist); // Larger radius of influence
                float hover_displacement = -0.025 * hover_falloff * u_hover_strength; // Stronger indent for more visibility
                total_displacement += hover_displacement;
            }
            
            vec2 displaced_uv = uv + total_displacement;

            // --- Liquid Flow & Color ---
            // Animate the noise patterns over time to create a flowing effect
            vec2 uv1 = displaced_uv * 1.5 + vec2(u_time * 0.05, u_time * 0.03);
            vec2 uv2 = displaced_uv * 2.0 - vec2(u_time * -0.07, u_time * 0.04);
            vec2 uv3 = displaced_uv * 2.5 + vec2(u_time * 0.1, u_time * -0.05);

            // Layering different noise patterns for a rich, oily texture
            float noise_pattern = fbm(uv1) * 0.5 + fbm(uv2) * 0.3 + fbm(uv3) * 0.2;
            
            // Reverted to original high-contrast color scheme for visibility
            float r = sin(noise_pattern * 4.0 + u_time * 0.2 + displaced_uv.x * 2.0) * 0.5 + 0.5;
            float g = cos(noise_pattern * 5.0 - u_time * 0.3 + displaced_uv.y * 3.0) * 0.5 + 0.5;
            float b = sin(noise_pattern * 6.0 + u_time * 0.1 - displaced_uv.x * 4.0) * 0.5 + 0.5;

            vec4 liquidColor = vec4(r, g, b, 1.0);
            vec4 finalColor = liquidColor;

            // --- Text Overlay Calculation ---
            // Only run if the text texture has been loaded (resolution > 0)
            if (u_textResolution.x > 0.0) {
                // Calculate the dimensions of the text box in pixels, with a max width of 1200px
                float textPixelWidth = min(1200.0, u_resolution.x * 0.9);
                float textAspect = u_textResolution.x / u_textResolution.y;
                float textPixelHeight = textPixelWidth / textAspect;

                // Convert pixel dimensions to UV space (0 to 1) and center the box
                vec2 boxSize = vec2(textPixelWidth / u_resolution.x, textPixelHeight / u_resolution.y);
                vec2 boxStart = 0.5 - boxSize * 0.5;

                // Check if the current pixel's ORIGINAL uv is inside the text's bounding box
                if (uv.x > boxStart.x && uv.x < boxStart.x + boxSize.x &&
                    uv.y > boxStart.y && uv.y < boxStart.y + boxSize.y) {

                    // Use the DISPLACED uv to sample the text, creating the distortion effect.
                    // We map the displaced screen UVs to the text's local UVs (0 to 1).
                    vec2 textUV = (displaced_uv - boxStart) / boxSize;
                    
                    // Flip the Y-coordinate to correct the upside-down text
                    textUV.y = 1.0 - textUV.y;
                    
                    vec4 textColor = texture2D(u_textTexture, textUV);

                    // Blend the white text over the liquid using the text's alpha channel and the scroll fade progress.
                    finalColor = mix(finalColor, vec4(textColor.rgb, 1.0), textColor.a * u_fade_progress);
                }
            }

            gl_FragColor = finalColor;
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        const logoElement = document.querySelector('.logo');
        const studioDescriptor = document.querySelector('.studio-descriptor');

        if (!gl) {
            alert('WebGL is not supported by your browser.');
        }

        // --- Shader Compilation & Program Linking ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(shaderProgram);

        // --- Geometry Setup (a simple plane to cover the screen) ---
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0,  1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- Uniforms (variables passed from JS to the shader) ---
        const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
        const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
        const rippleUniformLocation = gl.getUniformLocation(shaderProgram, 'u_ripples');
        const rippleVelocitiesUniformLocation = gl.getUniformLocation(shaderProgram, 'u_ripple_velocities');
        const textTextureUniformLocation = gl.getUniformLocation(shaderProgram, 'u_textTexture');
        const textResolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_textResolution');
        const fadeProgressUniformLocation = gl.getUniformLocation(shaderProgram, 'u_fade_progress');
        const hoverPosUniformLocation = gl.getUniformLocation(shaderProgram, 'u_hover_pos');
        const hoverStrengthUniformLocation = gl.getUniformLocation(shaderProgram, 'u_hover_strength');

        // --- Ripple Management ---
        const MAX_RIPPLES = 10;
        const ripples = [];
        const rippleVelocities = []; // New array for velocities
        for (let i = 0; i < MAX_RIPPLES; i++) {
            ripples.push({ x: 0, y: 0, startTime: -1, pressure: 0 });
            rippleVelocities.push({ x: 0, y: 0 }); // Initialize velocities
        }
        let currentRippleIndex = 0;
        let isInteracting = false; // Tracks mouse down or touch start
        let interactionStartTime = 0; // Tracks when a click/touch begins
        let lastInteractionPos = { x: 0, y: 0, time: 0 }; // For velocity calculation
        
        let lastRippleTime = 0; // For throttling mousemove events
        const rippleInterval = 50; // ms, create a ripple at most every 50ms (20fps)

        // --- Hover Management ---
        let hoverPos = { x: -1, y: -1 }; // Offscreen initially
        let targetHoverStrength = 0.0;
        let currentHoverStrength = 0.0;

        // --- Scroll Fade Management ---
        let fadeProgress = 1.0;

        // --- Text Texture Setup ---
        let textTexture = null;
        let textCanvas2d = null; // We'll store the 2D canvas element here

        function setupTextTexture() {
            // Create an offscreen 2D canvas to render the live text
            textCanvas2d = document.createElement('canvas');
            const ctx2d = textCanvas2d.getContext('2d');
            
            // Define text properties as requested
            const font = 'bold 60px "Cossette Texte", sans-serif';
            const text = 'WE MAKE EVERY IMPRESSION COUNT';
            const padding = 50; // The fix: Add 50px of transparent padding around the text
            
            // Apply font styles to measure the text width accurately
            ctx2d.font = font;
            ctx2d.letterSpacing = '1.2px';
            const metrics = ctx2d.measureText(text);
            const textWidth = metrics.width;
            const textHeight = 60 * 1.5; // Add some vertical padding for clarity

            // Set the canvas size to fit the text perfectly, PLUS the padding
            textCanvas2d.width = Math.ceil(textWidth) + padding * 2;
            textCanvas2d.height = Math.ceil(textHeight) + padding * 2;

            // Re-apply styles after resizing the canvas (this is a crucial step)
            ctx2d.font = font;
            ctx2d.letterSpacing = '1.2px';
            ctx2d.textAlign = 'center';
            ctx2d.textBaseline = 'middle';
            ctx2d.fillStyle = 'white';
            
            // Draw the text into the CENTER of the now larger (padded) canvas
            ctx2d.fillText(text, textCanvas2d.width / 2, textCanvas2d.height / 2);

            // Now, create a WebGL texture from this 2D canvas
            textTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, textTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas2d);

            // Set texture parameters for non-power-of-2 textures
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            
            // Start the render loop now that the texture is ready
            requestAnimationFrame(render);
        }


        // Helper function to create a ripple at a specific coordinate
        function createRipple(x, y) {
            const rect = canvas.getBoundingClientRect();
            const ripple = ripples[currentRippleIndex];
            const rippleVelocity = rippleVelocities[currentRippleIndex];

            // Calculate velocity
            const currentTime = performance.now();
            const dt = currentTime - lastInteractionPos.time;
            let velX = 0, velY = 0;

            // Only calculate velocity if there's a previous point and time has passed
            if (dt > 1 && lastInteractionPos.time > 0) {
                const dx = x - lastInteractionPos.x; // dx/dy in CSS pixels
                const dy = y - lastInteractionPos.y;

                // Velocity in normalized screen space units per second
                velX = (dx / canvas.clientWidth) / (dt / 1000.0);
                velY = -(dy / canvas.clientHeight) / (dt / 1000.0); // Flip Y and normalize
            }
            lastInteractionPos = { x, y, time: currentTime };
            
            // Store velocity for the shader
            rippleVelocity.x = velX;
            rippleVelocity.y = velY;

            // Calculate pressure based on how long the mouse has been held down, ramping up slower.
            const duration = interactionStartTime > 0 ? (performance.now() - interactionStartTime) / 1000.0 : 0;
            const pressure = Math.min(1.0, duration * 0.4); // Reaches max pressure in 2.5 seconds for a gentler effect
            
            // Convert pixel coords to WebGL normalized coords (0 to 1)
            ripple.x = (x - rect.left) / canvas.clientWidth;
            ripple.y = 1.0 - ((y - rect.top) / canvas.clientHeight); // Flip Y-axis
            ripple.startTime = performance.now() / 1000.0; // Store time in seconds
            ripple.pressure = pressure;

            // Cycle through the ripple array
            currentRippleIndex = (currentRippleIndex + 1) % MAX_RIPPLES;
        }

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', (event) => {
            isInteracting = true;
            interactionStartTime = performance.now();
            lastInteractionPos = { x: 0, y: 0, time: 0 }; // Reset on new click
            createRipple(event.clientX, event.clientY);
        });

        canvas.addEventListener('mousemove', (event) => {
            // Always track mouse position for the hover effect
            const rect = canvas.getBoundingClientRect();
            hoverPos.x = (event.clientX - rect.left) / canvas.clientWidth;
            hoverPos.y = 1.0 - ((event.clientY - rect.top) / canvas.clientHeight);

            if (isInteracting) {
                const now = performance.now();
                if (now - lastRippleTime > rippleInterval) {
                    createRipple(event.clientX, event.clientY);
                    lastRippleTime = now;
                }
            }
        });

        window.addEventListener('mouseup', () => {
            isInteracting = false;
            interactionStartTime = 0;
        });
        
        canvas.addEventListener('mouseenter', () => {
            targetHoverStrength = 1.0;
        });

        canvas.addEventListener('mouseleave', () => {
            targetHoverStrength = 0.0;
        });

        canvas.addEventListener('touchstart', (event) => {
            isInteracting = true;
            interactionStartTime = performance.now();
            lastInteractionPos = { x: 0, y: 0, time: 0 }; // Reset on new touch
            event.preventDefault(); 
            for (let i = 0; i < event.touches.length; i++) {
                createRipple(event.touches[i].clientX, event.touches[i].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (event) => {
            event.preventDefault();
            if (isInteracting) {
                const now = performance.now();
                if (now - lastRippleTime > rippleInterval) {
                    for (let i = 0; i < event.touches.length; i++) {
                        createRipple(event.touches[i].clientX, event.touches[i].clientY);
                    }
                    lastRippleTime = now;
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            isInteracting = false;
            interactionStartTime = 0;
        });

        // --- Scroll Listener for Fade Effect ---
        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY;
            const fadeStart = 50;
            const fadeEnd = 400;

            let progress = 0;
            if (scrollY > fadeStart) {
                progress = Math.min(1, (scrollY - fadeStart) / (fadeEnd - fadeStart));
            }

            fadeProgress = 1.0 - progress;
            const blurAmount = progress * 10; // Max blur of 10px

            logoElement.style.opacity = fadeProgress;
            logoElement.style.filter = `blur(${blurAmount}px)`;
            studioDescriptor.style.opacity = fadeProgress;
            studioDescriptor.style.filter = `blur(${blurAmount}px)`;
        });


        // --- Render Loop ---
        let lastFrameTime = 0;
        const targetFPS = 40;
        const frameInterval = 1000 / targetFPS;

        function render(time) {
            requestAnimationFrame(render);

            const elapsed = time - lastFrameTime;

            // Throttle the frame rate
            if (elapsed < frameInterval) {
                return;
            }
            lastFrameTime = time - (elapsed % frameInterval);

            const timeInSeconds = time * 0.001; // convert time to seconds

            // Resize canvas to match display size
            const dpr = window.devicePixelRatio || 1;
            const displayWidth = Math.round(canvas.clientWidth * dpr);
            const displayHeight = Math.round(canvas.clientHeight * dpr);

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            // Ease hover strength for a smooth transition
            currentHoverStrength += (targetHoverStrength - currentHoverStrength) * 0.1;

            // Update uniforms
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            gl.uniform1f(timeUniformLocation, timeInSeconds);
            gl.uniform1f(fadeProgressUniformLocation, fadeProgress); // Pass fade progress to shader
            gl.uniform2f(hoverPosUniformLocation, hoverPos.x, hoverPos.y);
            gl.uniform1f(hoverStrengthUniformLocation, currentHoverStrength);


            // Prepare ripple data for the shader
            const rippleData = new Float32Array(MAX_RIPPLES * 4);
            const rippleVelocitiesData = new Float32Array(MAX_RIPPLES * 2);

            ripples.forEach((ripple, i) => {
                // If a ripple is too old, reset its start time so the shader ignores it.
                if (timeInSeconds - ripple.startTime > 7.0) { // 7s is a safe cleanup time
                    ripple.startTime = -1.0;
                }
                const offset = i * 4;
                rippleData[offset] = ripple.x;
                rippleData[offset + 1] = ripple.y;
                rippleData[offset + 2] = ripple.startTime;
                rippleData[offset + 3] = ripple.pressure;

                // Populate velocity data
                const velOffset = i * 2;
                const velocity = rippleVelocities[i];
                if (ripple.startTime < 0.0) { // If ripple is inactive, zero out velocity
                    rippleVelocitiesData[velOffset] = 0.0;
                    rippleVelocitiesData[velOffset + 1] = 0.0;
                } else {
                    rippleVelocitiesData[velOffset] = velocity.x;
                    rippleVelocitiesData[velOffset + 1] = velocity.y;
                }
            });
            gl.uniform4fv(rippleUniformLocation, rippleData);
            gl.uniform2fv(rippleVelocitiesUniformLocation, rippleVelocitiesData); // Send velocities

            // Update text texture uniforms if the texture is ready
            if (textTexture) {
                gl.uniform2f(textResolutionUniformLocation, textCanvas2d.width, textCanvas2d.height);
                
                // Tell the shader to use texture unit 0 for u_textTexture
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, textTexture);
                gl.uniform1i(textTextureUniformLocation, 0);
            }
            
            // Draw the scene
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // requestAnimationFrame(render); // Moved to the top of the function
        }

        // Start the process by setting up the text texture, 
        // which will then kick off the render loop.
        setupTextTexture();
    </script>
</body>
</html>



